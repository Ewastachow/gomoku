<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>AI</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_AI.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">AI</p></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:GameTree">GameTree</a> = <a href="#v:GameTree">GameTree</a> {<ul class="subs"><li><a href="#v:game_board">game_board</a> :: <a href="Board.html#t:Board">Board</a></li><li><a href="#v:game_turn">game_turn</a> :: <a href="Board.html#t:Col">Col</a></li><li><a href="#v:next_moves">next_moves</a> :: [(<a href="Board.html#t:Position">Position</a>, <a href="AI.html#t:GameTree">GameTree</a>)]</li></ul>}</li><li class="src short"><a href="#v:gen">gen</a> :: <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; [<a href="Board.html#t:Position">Position</a>]</li><li class="src short"><a href="#v:surrounding">surrounding</a> :: [(<a href="Board.html#t:Position">Position</a>, <a href="Board.html#t:Col">Col</a>)] -&gt; <a href="Board.html#t:Col">Col</a> -&gt; [<a href="Board.html#t:Position">Position</a>]</li><li class="src short"><a href="#v:buildTree">buildTree</a> :: (<a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; [<a href="Board.html#t:Position">Position</a>]) -&gt; <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; <a href="AI.html#t:GameTree">GameTree</a></li><li class="src short"><a href="#v:getBestMove">getBestMove</a> :: Int -&gt; <a href="AI.html#t:GameTree">GameTree</a> -&gt; <a href="Board.html#t:Position">Position</a></li><li class="src short"><a href="#v:getBestMoveRecursive">getBestMoveRecursive</a> :: [(<a href="Board.html#t:Position">Position</a>, <a href="AI.html#t:GameTree">GameTree</a>)] -&gt; Int -&gt; <a href="Board.html#t:Position">Position</a> -&gt; Int -&gt; <a href="Board.html#t:Position">Position</a></li><li class="src short"><a href="#v:displayPoss">displayPoss</a> ::  [(t, b)] -&gt; [t]</li><li class="src short"><a href="#v:bestOfEvals">bestOfEvals</a> :: [(<a href="Board.html#t:Position">Position</a>, <a href="AI.html#t:GameTree">GameTree</a>)] -&gt; <a href="Board.html#t:Col">Col</a> -&gt; Int -&gt; <a href="Board.html#t:Position">Position</a> -&gt; (<a href="Board.html#t:Position">Position</a>, Int)</li><li class="src short"><a href="#v:bestOfTrees">bestOfTrees</a> :: [(<a href="Board.html#t:Position">Position</a>, <a href="AI.html#t:GameTree">GameTree</a>)] -&gt; Int -&gt; Int -&gt; <a href="Board.html#t:Position">Position</a> -&gt; (<a href="Board.html#t:Position">Position</a>, Int)</li><li class="src short"><a href="#v:findPos">findPos</a> :: [(<a href="Board.html#t:Position">Position</a>, <a href="AI.html#t:GameTree">GameTree</a>)] -&gt; <a href="Board.html#t:Position">Position</a> -&gt; [(<a href="Board.html#t:Position">Position</a>, <a href="AI.html#t:GameTree">GameTree</a>)]</li><li class="src short"><a href="#v:better">better</a> :: (<a href="Board.html#t:Position">Position</a>, Int) -&gt; (<a href="Board.html#t:Position">Position</a>, Int) -&gt; (<a href="Board.html#t:Position">Position</a>, Int)</li><li class="src short"><a href="#v:updateWorld">updateWorld</a> :: Float -&gt; IO <a href="Board.html#t:World">World</a> -&gt; IO (IO <a href="Board.html#t:World">World</a>)</li><li class="src short"><a href="#v:isAITurn">isAITurn</a> :: <a href="Board.html#t:Col">Col</a> -&gt; (Int, Int) -&gt; Bool</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:GameTree" class="def">GameTree</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:GameTree" class="def">GameTree</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:game_board" class="def">game_board</a> :: <a href="Board.html#t:Board">Board</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:game_turn" class="def">game_turn</a> :: <a href="Board.html#t:Col">Col</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:next_moves" class="def">next_moves</a> :: [(<a href="Board.html#t:Position">Position</a>, <a href="AI.html#t:GameTree">GameTree</a>)]</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><a name="v:gen" class="def">gen</a> :: <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; [<a href="Board.html#t:Position">Position</a>]</p><div class="doc"><p>weak move gen function:
 |generates all moves next to a move of player's own color,
 |or a couple moves in the middle if player's first turn
 |(returning only one might lead to no moves being generated for the second player)
 |note: this will generate lots of moves on occupied spaces or off the edge of the board,
 |but buildTree will screen them out.</p></div></div><div class="top"><p class="src"><a name="v:surrounding" class="def">surrounding</a> :: [(<a href="Board.html#t:Position">Position</a>, <a href="Board.html#t:Col">Col</a>)] -&gt; <a href="Board.html#t:Col">Col</a> -&gt; [<a href="Board.html#t:Position">Position</a>]</p><div class="doc"><p>Takes a list of positions and their colors plus a color argument,
 |and returns the board positions adjacent to a all the pieces of the given color. </p></div></div><div class="top"><p class="src"><a name="v:buildTree" class="def">buildTree</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; [<a href="Board.html#t:Position">Position</a>])</td><td class="doc"><p>Move generator</p></td></tr><tr><td class="src">-&gt; <a href="Board.html#t:Board">Board</a></td><td class="doc"><p>board state</p></td></tr><tr><td class="src">-&gt; <a href="Board.html#t:Col">Col</a></td><td class="doc"><p>player to play next</p></td></tr><tr><td class="src">-&gt; <a href="AI.html#t:GameTree">GameTree</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Given a function to generate plausible moves (i.e. board positions)
 |for a player (Col) on a particular board, generate a (potentially)
 |infinite game tree.</p><p>|(It's not actually infinite since the board is finite, but it's sufficiently
 |big that you might as well consider it infinite!)</p><p>|An important part of the AI is the <code><a href="AI.html#v:gen">gen</a></code> function you pass in here.
 |Rather than generating every possible move (which would result in an
 |unmanageably large game tree!) it could, for example, generate moves
 |according to various simpler strategies.</p></div></div><div class="top"><p class="src"><a name="v:getBestMove" class="def">getBestMove</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Int</td><td class="doc"><p>Maximum search depth</p></td></tr><tr><td class="src">-&gt; <a href="AI.html#t:GameTree">GameTree</a></td><td class="doc"><p>Initial game tree</p></td></tr><tr><td class="src">-&gt; <a href="Board.html#t:Position">Position</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Get the best next move from a (possibly infinite) game tree. This should
 |traverse the game tree up to a certain depth, and pick the move which
 |leads to the position with the best score for the player whose turn it
 |is at the top of the game tree.
 |if not at the max depth, iterate over all the gameTrees in next_moves
 |if at the max depth, return the best position and value in nextMoves
 data GameTree = GameTree { game_board :: Board,
                          game_turn :: Col,
                        next_moves :: [(Position, GameTree)] }</p></div></div><div class="top"><p class="src"><a name="v:getBestMoveRecursive" class="def">getBestMoveRecursive</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [(<a href="Board.html#t:Position">Position</a>, <a href="AI.html#t:GameTree">GameTree</a>)]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>max simulation depth</p></td></tr><tr><td class="src">-&gt; <a href="Board.html#t:Position">Position</a></td><td class="doc"><p>best position so far</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>best value so far</p></td></tr><tr><td class="src">-&gt; <a href="Board.html#t:Position">Position</a></td><td class="doc"><p>final move to make in the real game</p></td></tr></table></div><div class="doc"><p>Handles the top-level part of move choice that directly compares 
 |the predicted desirability of the futures of the immediate possible moves.</p></div></div><div class="top"><p class="src"><a name="v:displayPoss" class="def">displayPoss</a> ::  [(t, b)] -&gt; [t]</p></div><div class="top"><p class="src"><a name="v:bestOfEvals" class="def">bestOfEvals</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [(<a href="Board.html#t:Position">Position</a>, <a href="AI.html#t:GameTree">GameTree</a>)]</td><td class="doc"><p>positions and their results to examine</p></td></tr><tr><td class="src">-&gt; <a href="Board.html#t:Col">Col</a></td><td class="doc"><p>color to maximize for</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>best value so far (for recursion along list)</p></td></tr><tr><td class="src">-&gt; <a href="Board.html#t:Position">Position</a></td><td class="doc"><p>best position so far (for recursion along list)</p></td></tr><tr><td class="src">-&gt; (<a href="Board.html#t:Position">Position</a>, Int)</td><td class="doc"><p>best position found and its value</p></td></tr></table></div><div class="doc"><p>where the game tree recursion bottoms out. Evaluates various eventual board states and determines the best case.</p></div></div><div class="top"><p class="src"><a name="v:bestOfTrees" class="def">bestOfTrees</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [(<a href="Board.html#t:Position">Position</a>, <a href="AI.html#t:GameTree">GameTree</a>)]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>max depth</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>current Depth</p></td></tr><tr><td class="src">-&gt; <a href="Board.html#t:Position">Position</a></td><td class="doc"><p>suggested top-level move position</p></td></tr><tr><td class="src">-&gt; (<a href="Board.html#t:Position">Position</a>, Int)</td><td class="doc"><p>suggested top-level move position and its eventual value</p></td></tr></table></div><div class="doc"><p>If at the maximum depth, evaluate the boards in all the gametrees and return the position associated with the best one
 |aka call bestOfEvals on the list and return that
 |If not at the maximum depth, evaluate the boards in all the gametrees, take the best one, and call bestOfTrees on it at depth+1
 |aka call bestOfEvals on the list, find the (Pos,gametree) associated with the winning (pos,int), call bestoftrees again </p></div></div><div class="top"><p class="src"><a name="v:findPos" class="def">findPos</a> :: [(<a href="Board.html#t:Position">Position</a>, <a href="AI.html#t:GameTree">GameTree</a>)] -&gt; <a href="Board.html#t:Position">Position</a> -&gt; [(<a href="Board.html#t:Position">Position</a>, <a href="AI.html#t:GameTree">GameTree</a>)]</p><div class="doc"><p>Takes a list of positions and game trees and a position and returns the next_moves of the game tree paired with the position</p></div></div><div class="top"><p class="src"><a name="v:better" class="def">better</a> :: (<a href="Board.html#t:Position">Position</a>, Int) -&gt; (<a href="Board.html#t:Position">Position</a>, Int) -&gt; (<a href="Board.html#t:Position">Position</a>, Int)</p><div class="doc"><p>A deprecated helper function for bestOfEvals
 | Takes two pairs of positions and evaluation values and returns the one with the higher value. A helper function</p></div></div><div class="top"><p class="src"><a name="v:updateWorld" class="def">updateWorld</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Float</td><td class="doc"><p>time since last update (you can ignore this)</p></td></tr><tr><td class="src">-&gt; IO <a href="Board.html#t:World">World</a></td><td class="doc"><p>current world state</p></td></tr><tr><td class="src">-&gt; IO (IO <a href="Board.html#t:World">World</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Update the world state after some time has passed</p></div></div><div class="top"><p class="src"><a name="v:isAITurn" class="def">isAITurn</a> :: <a href="Board.html#t:Col">Col</a> -&gt; (Int, Int) -&gt; Bool</p><div class="doc"><p>Determine whether it's an AI's turn to play</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>